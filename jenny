#!/usr/bin/env bash

BLOGRC="$PWD/.blogrc"

# Load configuration on current dir
if [ -f "$BLOGRC" ]; then
  source $BLOGRC
else
  echo "This is not a blog. Exiting.";
  exit 0
fi

# Checks if user is on macOS and checks for dependencies
# Also handles suppresion of this very message
if [ -z "$SUPPRESS_UTILS_WARN" ] && [[ "$(uname -a)" == *"Darwin"*  && ( -z "$(which gsed)" || -z "$(which gawk)" ) ]]; then
  echo -e "macOS users need 'gsed' and 'gawk', install them via: brew install gawk gnu-sed\n"
  echo -e "If you installed them with --with-default-names, i.e. as sed and awk, then add the below to your .blogrc file to suppress this warning:\n\n  SUPPRESS_UTILS_WARN=1\n"
  echo "Exiting."
  exit 0
fi

# Prepares last modification/compiled database
touch $PWD/.lastcompiled

# Set posts_per_page if not set in .blogrc
[ -z "$POSTS_PER_PAGE" ] && POSTS_PER_PAGE=5

# Use project dir when symlinked
if [[ "$(uname -a)" == *"Darwin"* ]]; then
  SCRIPT_DIR=$(dirname "$(readlink $(which $BASH_SOURCE))")
else
  SCRIPT_DIR=$(dirname -- "$(readlink -e -- $BASH_SOURCE)")
fi

# Populate flag to check if installed
if [[ $SCRIPT_DIR = "." ]]; then
  ABSOLUTE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

if [ -z "$ABSOLUTE_DIR" ]; then
  # Not installed, use project paths
  [ -z "$LAYOUT_DIR" ] && LAYOUT_DIR=$SCRIPT_DIR/share/layout
  MARKDOWN=$SCRIPT_DIR/share/lib/md2html.awk
else
  # Installed, use installation paths
  [ -z "$LAYOUT_DIR" ] && LAYOUT_DIR=/usr/local/share/jenny/layout
  MARKDOWN=/usr/local/share/jenny/lib/md2html.awk
fi

# Use GNU utils if present
[ "$(which gsed)" ] && sed=$(which gsed) || sed=$(which sed)
[ "$(which gawk)" ] && awk=$(which gawk) || awk=$(which awk)

# Check if trying to rebuild just one page - currently broken
if [ "$1" ]; then
  TARGET_EXISTS=false
  echo "Only building $1"
else
  echo "Rebuilding all"

  # Clean dist folder if rebuild all
  rm -f $DIST/index.html
  rm -rf $DIST/page/
  rm -rf $DIST/tag/
	rm -rf /tmp/jenny*
fi

# Create directories for pseudo subdirs
mkdir -p $DIST/post
mkdir -p $DIST/page

# Declaring Global Variables
fullfilename=""
extension=""
filename=""
slug=""
timestamp=""
postdate=""
postdateint=""
publish_pattern="^[0-9]{4}-[0-9]{2}-[0-9]{2}(.*)"
ceiling_divide() {
  ceiling_result=$((($1+$2-1)/$2))
}

totalpostcount=0
# This weird sub gets roof value after division
totalpagecount=0
postcount=0
pagecount=0

declare -a index_list

function join_by { local IFS="$1"; shift; echo "$*"; }

# Used to generate info from filename
parse_details () {
  # Grab file details
  fullfilename=$(basename "$1")
  extension="${fullfilename##*.}"
  filename="${fullfilename%.*}"
  slug=$(echo "$filename" | rev | cut -d ' ' -f 1 | rev)
  id=$(echo "$fullfilename" | rev | cut -d ' ' -f 2 | rev)
  timestamp=$(cut -d ' ' -f -1 <<< "$filename")
  postdate=$(echo $timestamp | $sed -e 's#\([0-9]\{4\}\)-\([0-9]\{2\}\)-\([0-9]\{2\}\)#\2/\3#')
  postdatefull=$(echo $timestamp | $sed -e 's#\([0-9]\{4\}\)-\([0-9]\{2\}\)-\([0-9]\{2\}\)#\1\ \2\-\3#')
  postdateint=$(echo $timestamp | $sed -e 's#\([0-9]\{4\}\)-\([0-9]\{2\}\)-\([0-9]\{2\}\)#\1\2\3#')
}

# Used to find available permalink if slug not unique
find_permalink () {
  if [[ -e $dest ]] ; then
    echo "  Permalink taken, finding unique increment number"
    i=2
    while [[ -e $DIST/post/$slug-$i.html ]] ; do
      let i++
    done
    slug=$slug-$i
  fi
  dest="$DIST/post/$slug.html"
}

# Creates individual post pages
render () {
  # Copy source file to a temp file
  cp "$f" /tmp/jennysrc

  # Delete the tagline from the temp file
  $sed -i '/^tags\: .*/d' /tmp/jennysrc

  # Run markdown interpreter
  $awk -f $MARKDOWN /tmp/jennysrc > /tmp/jennyrender

  # Grab the title, and delete the tag
  title=$(grep -E "<h1.*>(.*?)</h1>" /tmp/jennyrender | $sed 's/<h1.*>\(.*\)<\/h1>.*/\1/')
  $sed -i 's/<h1.*>.*<\/h1>//' /tmp/jennyrender

  # Push variables to template file
  POST_TITLE=$title POST_URL="/post/$slug.html" POST_DATE=$postdate POST_CONTENTS=$(cat /tmp/jennyrender) TAGS=$TAGS TAGNAME=$TAGNAME $LAYOUT_DIR/post.sh > $dest
}


# Inserts each article into an index or pagination page
index_insert () {

	DIST=$DIST

  if [ $TAGNAME ]; then
    ROOT="/tag/$TAGNAME"
  else
    ROOT=""
  fi

  # Create the export line for the index.sh template
  index_list+=("POST_URL=\"/post/$slug.html\" POST_TITLE=\"$(echo $title | sed 's#\"#\\\"#')\" POST_DATE=\"$postdate\"")

  # Count the posts so we can limit them per page
  let postcount++

  page=$((($postcount+$POSTS_PER_PAGE-1)/$POSTS_PER_PAGE))
  new_page=$(( $postcount % $POSTS_PER_PAGE ))

  # Create page when we have enough for a page
  # Or when we don't have any more
  if (( $new_page == 0 )) || (( $postcount == $totalpostcount )); then
    echo "CREATED PAGE $page"
    echo ""

    # Add the older page nav
    [[ $(( page - 1 )) > 0 ]] && PAGE_OLD="$ROOT/page/$(( page - 1 )).html" || PAGE_OLD=""

    # Add the newer page nav
    if (( $page+1 == $totalpagecount )); then
      PAGE_NEW="$ROOT/"
    else
      PAGE_NEW="$ROOT/page/$(( page + 1 )).html"
    fi

    let pagecount++

    # This is where we should generate the heredocs template for index
    if (( $page == $totalpagecount )); then
      INDEX_LIST=$(join_by '✂︎' "${index_list[@]}")
      LIST="$INDEX_LIST" PAGE_OLD=$PAGE_OLD $LAYOUT_DIR/index.sh > "$DIST/index.html"
    else
      INDEX_LIST=$(join_by '✂︎' "${index_list[@]}")
      mkdir -p $DIST/page
      LIST="$INDEX_LIST" PAGE_OLD=$PAGE_OLD PAGE_NEW=$PAGE_NEW $LAYOUT_DIR/index.sh > "$DIST/page/${page}.html"
    fi

    # Reset array for a new page
    unset index_list

  fi

}

begin () {

	DIST=$DIST
	echo "Working in $DIST"

  # Grabbing the array argument
  list=("$@")

	totalpostcount=$(printf "%s\n"  "${list[@]}" | \
    grep -E '^[0-9]{4}\-[0-9]{2}\-[0-9]{2}(.*)' | \
    wc -l)
	totalpagecount=$((($totalpostcount+$POSTS_PER_PAGE-1)/$POSTS_PER_PAGE))

  # Reset variables
  postcount=0
  pagecount=0

  # Loop through file list in expanded array
  for f in "${list[@]}"; do

    # Grab file details
    parse_details "$f"

    # Grabe the tags
    tagline=`cat "$f" | grep -m 1 "^tags: "`
    tags=`echo $tagline | $sed -e 's/tags\: \(.*\)/\1/'`
    for i in $tags; do
      echo "$f" >> "/tmp/jennytag_$i"
    done

    # Process source files if not working on tag index
    if [ -z "$TAGNAME" ]; then

      CURRENT_ISNEW=true

      # If there's no date, then it's a draft
      if ! [[ $filename =~ $publish_pattern ]]; then
        echo "• Draft: $fullfilename file..";
        continue
      fi

      # If the date is in the future, then it's scheduled
      if (( $postdateint > $(date +"%Y%m%d") )); then
        echo "• Scheduled: $fullfilename file..";
        continue
      fi

      # Check if changed since last compile
      LAST_MODIFIED_DATE=$(date -r "$f" +%s)
      COMPILE_RECORD=$(grep "$fullfilename" $PWD/.lastcompiled)
      COMPILE_RECORD_LMD=$(echo $COMPILE_RECORD | $sed 's/.*\ //')
      #if [ "$COMPILE_RECORD" ] && (( LAST_MODIFIED_DATE < COMPILE_RECORD_LMD)); then
      if [ "$COMPILE_RECORD" ] && (( LAST_MODIFIED_DATE <= COMPILE_RECORD_LMD )); then
        echo "• Skipping: $fullfilename";
        CURRENT_ISNEW=true
        RENDER=false
      else
        $sed -i "/$(echo $fullfilename | $sed 's/ /\\ /g')/d" $PWD/.lastcompiled
        echo "$fullfilename $LAST_MODIFIED_DATE" >> $PWD/.lastcompiled
        echo "☶ $fullfilename file..";
        CURRENT_ISNEW=false
        RENDER=true
      fi

      echo "  - post/$slug.html"
      # If page is for rendering
      if [ $RENDER == true ] && ( [ -z "$1" ] || [ $CURRENT_ISNEW == false ] ); then

        # Find available permalink
        dest="$DIST/post/$slug.html"

        # No need to look if not new ( $CURRENT_ISNEW == false )
        # $slug will already be set correctly
        if [ $CURRENT_ISNEW == true ]; then
          find_permalink
        fi

        TAGNAME=$TAGNAME TAGS=$tags render

      else
        title=$(grep -E "^\#\ (.*?)" "$f" | \
          $sed 's/^\#\ \(.*\)/\1/' | \
          $sed -r 's/\\(.)/\1/g' )
      fi

    else
      title=$(grep -E "^\#\ (.*?)" "$f" | \
        $sed 's/^\#\ \(.*\)/\1/' | \
        $sed -r 's/\\(.)/\1/g' )
      echo "+ $fullfilename file..";
    fi # Checks if working on tag index

    # Finally insert to the current index page
    DIST=$DIST TAGNAME=$TAGNAME TAGS=$tags index_insert

  done
}

# Get files in current directory
file_list=(*.md)

# Start generation
begin "${file_list[@]}"

# Now generate indexes for tags
OIFS="$IFS"
for i in `ls /tmp/jennytag_*`; do
	tagname=`echo $i | $sed "s/\/tmp\/jennytag_//"`
	mkdir -p $DIST/tag/$tagname
	IFS=$'\r\n' GLOBIGNORE='*' command eval "LIST=(\$(cat $i))"
	DIST=$DIST/tag/$tagname TAGFILE=$i TAGNAME=$tagname begin "${LIST[@]}"
done
IFS="$OIFS"

# Run the user defined hook
[ "$(type -t post_hook)" = function ] && post_hook
